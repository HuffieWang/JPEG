#简介
##硬件
&emsp;&emsp;主控芯片：STM32F407ZET6

&emsp;&emsp;拓展内存：IS62WV51216BLL(1Mbyte)

&emsp;&emsp;液晶显示：ILI9341彩屏(320*240像素)

&emsp;&emsp;原图信息：320*240像素、RGB565模式的lenna局部图
##算法
&emsp;&emsp;颜色模式：YUV

&emsp;&emsp;压缩算法：DCT变换

&emsp;&emsp;编码方法：行程编码、霍夫曼编码

&emsp;&emsp;压缩比例：13：1
#算法原理及实现
##颜色模式转换
###说明
&emsp;&emsp;将RGB565模式的原图像转换为YUV模式。RGB模式由Red（红）、Green（绿）、Blue（蓝）三原色组成，YUV模式由Y（亮度）、U（色度）、V（饱和度）组成，详细介绍见百度百科。
###原因
&emsp;&emsp;研究发现，人眼对亮度变换的敏感度要比对色彩（色度和饱和度）变换的敏感度高出很多。利用这个特性，我们可以对YUV模式的图像进行亮度权重较高、色度权重较低的采样，得到数据量更小的图片，同时损失的精度又不易被人眼察觉。RGB模式显然不具备这种优势，所以需要进行转换。

![image](https://github.com/HuffieWang/JPEG/tree/master/DATA/lenna.jpg)

&emsp;&emsp;YUV常用的采样比例有4：1：1和4：2：2等，本设计中因为在等比采样时的压缩率已达成设计要求，所以采用YUV按1：1：1的采样来保证最好的图像质量。
###原理
&emsp;&emsp;RGB转YUV的常用公式：
```C
     Y =  0.299*red + 0.587*green + 0.114*blue; 
     U = -0.1687*red - 0.3313*green + 0.5*blue + 128;
     V = 0.5*red - 0.418*green - 0.0813*blue + 128; 
```
&emsp;&emsp;YUV转RGB的常用公式：
```C
     red = Y + 1.402 * (V-128);
     green = Y - 0.34414 * (U-128) - 0.71414 * (V-128);
     blue = Y + 1.772 * (U-128);
```
&emsp;&emsp;以上所有公式中的red、green、blue、Y、U、V的值域均为0~255。
###实现
&emsp;&emsp;因原始图像为RGB565格式，所以需先将其分离为8位的red、green、blue分量，C语言实现方法如下。
```C
     //RGB565转RGB888
     red = (rgb565 & 0xF800) >> 8;   
     green = (rgb565 & 0x07E0) >> 3;
     blue = (rgb565 & 0x001F) << 3;
     
     //RGB888转RGB565
     rgb565 = ((red/8) << 11) | ((g/8) << 6) | (b/8);
```
&emsp;&emsp;又因后续的DCT变换所能处理的数值范围为-127~+127，所以需将RGB转YUV得的到数值均减去128；同理，在YUV转RGB时，均加上128。C语言实现方法如下。
```C
     //RGB888转YUV
     Y = 0.299f*red + 0.587f*green + 0.114f*blue - 128; 
     U = -0.1687f*red - 0.3313f*green + 0.5f*blue;             
     V = 0.5f*red - 0.418f*green - 0.0813f*blue; 
     
     //YUV转RGB888
     red = Y + 1.402*V + 128;
     green = Y - 0.34414*U - 0.71414*V + 128;
     blue = Y + 1.772*U + 128;
```
&emsp;&emsp;注：为使描述直观，将原代码做了简化，完整版见User\ JPEG\ hnit_jpeg.c\ "rgb565_to_yuv"和"yuv_to_rgb565"。
##数据分块
###说明
&emsp;&emsp;将YUV图像数据分为Y、U、V三组图层数据，并将每个图层划分为若干个8x8的数据块。
###原因
&emsp;&emsp;JPEG采用处理完一整个图层后，再处理下一图层的方法，这样无论是编码还是解码都比较方便，所以需要分层。同时，JPEG是以每8x8个点为一个单位进行处理的，所以需要将图层进行分块。
###原理
&emsp;&emsp;分层处理在颜色模式转换步骤中已经完成；分块处理只需按从左到右、从上到下的顺序从图层数据中取出8x8的数据，依次存放在64长度的数组中即可。
###实现
```C
    //分块
    for(m = 0; m < 8; m++)
        for(n = 0; n < 8; n++)
            temp[m*8+n] = yuv[(i*8+m)*240+j*8+n];
    //还原
    for(m = 0; m < 8; m++)
        for(n = 0; n < 8; n++)
            yuv[((i/30)*8+m)*240+(i%30)*8+n] = temp[m*8+n];
```
&emsp;&emsp;注：为使描述直观，将原代码做了简化，完整版见User\ JPEG\ hnit_jpeg.c\ "jpeg_encode"和"jpeg_decode"。
##DCT变换
###说明
&emsp;&emsp;将8x8的图像数据变换为8x8的频域系数矩阵，例如，U=0，V=0时的F（0,0）是原来的64个数据的均值，相当于直流分量，也有人称之为DC系数或者直流系数。随着U，V的增加，相另外的63个系数则代表了水平空间频率和垂直空间频率分量（高频分量）的大小，多半是一些接近于0的正负浮点数，我们称之为交流系数AC。DCT变换后的8x8的系数矩阵中，低频分量集中在矩阵的左上角。高频成分则集中在右下角。
###原因
&emsp;&emsp;DCT变换是JEPG图像压缩的核心部分。由于大多数图像的高频分量比较小，相应的图像高频分量的DCT系数经常接近于0，再加上高频分量中只包含了图像的细微的细节变化信息，而人眼对这种高频成分的失真不太敏感，所以，可以考虑将这一些高频成分予以抛弃，从而降低需要传输的数据量。这样一来，传送DCT变换系数的所需要的编码长度要远远小于传送图像像素的编码长度。到达接收端之后通过反离散余弦变换就可以得到原来的数据，虽然这么做存在一定的失真，但人眼是可接受的，而且对这种微小的改变是不敏感的。
###原理
&emsp;&emsp;图像信号通过DCT被分解为直流成分和一些从低频到高频的各种余弦成分。而DCT系数只表示了该种成分所占原图像信号的份额大小。
###实现
&emsp;&emsp;蝶形算法。
##Zigzag排序
###说明
